if (input[check] == 0) {
check_count <- check_count + 1
}
else {
input_clean <- subset(input, start = check_count + 1)
break
}
}
input
subset(input)
install.packages("forecast")
install.packages("forecast")
forecast:::subset.ts(input, start = check_count + 1)
x <- AirPassengers
if(is.ts(series)==FALSE){
x <- ts(series, freq=freq)
} else {
x <- series
}
for (check in 1:length(x)) {
if (x[check] == 0) {
check_count <- check_count + 1
}
else {
x <- subset.ts(x, start = check_count + 1) # this is a forecast function that mask the base one
break
}
}
require(forecast)
for (check in 1:length(x)) {
if (x[check] == 0) {
check_count <- check_count + 1
}
else {
x <- subset(x, start = check_count + 1) # this is a forecast function that mask the base one
break
}
}
x
c(0,0,0, x)
ts(c(0,0,0, x))
ts(c(0,0,0, x), frequency = 12)
x <- ts(c(0,0,0, x), frequency = 12)
x <- ts(c(0,0,0, x), frequency = 12)
for (check in 1:length(x)) {
if (x[check] == 0) {
check_count <- check_count + 1
}
else {
x <- subset(x, start = check_count + 1) # this is a forecast function that mask the base one
break
}
}
x
tscut <- function(series, freq=12) { # argument can be a vector or ts object
x_1 <- c(10, 100, 1000, 10000)
y <- c(10, 4, 2, 1.5)
fit <- lm(log(y) ~ log(x_1))
p_1 <- fit$coefficients[2]
p_2 <- exp(fit$coefficients[1])
# if it is a numeric vector convert is as monthly time series
if(is.ts(series)==FALSE){
x <- ts(series, freq=freq)
} else {
x <- series
}
if (length(x) != 0) {
check_count <- 0
for (check in 1:length(x)) {
if (x[check] == 0) {
check_count <- check_count + 1
}
else {
x <- subset(x, start = check_count + 1) # this is a forecast function that mask the base one
break
}
}
x_no_leading_zeros <- x
if (length(x) >= 4) {
dfu_break <- cpt.meanvar(x, penalty = "None", method = "AMOC", Q = 1)
bp <- cpts(dfu_break)
x_after <- subset(x, start = bp + 1)
dfu_break_var <- cpt.var(x, penalty = "None", method = "AMOC", Q = 1)
bp_var <- cpts(dfu_break_var)
x_after_var <- subset(x, start = bp_var + 1)
if (length(x_after) > 24) {
min_mean <- min(mean(x[1:bp]), mean(x[bp:length(x)]))
max_mean <- max(mean(x[1:bp]), mean(x[bp:length(x)]))
threshold <- p_2 * min_mean^p_1
if (max_mean / min_mean >= threshold) {
x <- x_after
} else {
if (length(x_after_var) > 24) {
min_iqr <- min(IQR(x[1:bp_var]), IQR(x[bp_var:length(x)])) + 0.0001
max_iqr <- max(IQR(x[1:bp_var]), IQR(x[bp_var:length(x)]))
if (max_iqr / min_iqr > 2) {
x <- x_after_var
} else {
x <- x
}
} else {
x <- x
}
}
if (x[1] == 0) {
x <- x_no_leading_zeros
}
return(x)
} else {
if (length(x_after_var) > 24) {
min_iqr <- min(IQR(x[1:bp_var]), IQR(x[bp_var:length(x)])) + 0.0001
max_iqr <- max(IQR(x[1:bp_var]), IQR(x[bp_var:length(x)]))
if (max_iqr / min_iqr > 2) {
x <- x_after_var
} else {
x <- x
}
} else {
x <- x
}
if (x[1] == 0) {
x <- x_no_leading_zeros
}
return(x)
}
} else {
x <- x
return(x)
}
}
}
tscut(AirPassengers)
require(changepoint)
require(changepoint)
tscut <- function(series, freq=12) { # argument can be a vector or ts object
x_1 <- c(10, 100, 1000, 10000)
y <- c(10, 4, 2, 1.5)
fit <- lm(log(y) ~ log(x_1))
p_1 <- fit$coefficients[2]
p_2 <- exp(fit$coefficients[1])
# if it is a numeric vector convert is as monthly time series
if(is.ts(series)==FALSE){
x <- ts(series, freq=freq)
} else {
x <- series
}
if (length(x) != 0) {
check_count <- 0
for (check in 1:length(x)) {
if (x[check] == 0) {
check_count <- check_count + 1
}
else {
x <- subset(x, start = check_count + 1) # this is a forecast function that mask the base one
break
}
}
x_no_leading_zeros <- x
if (length(x) >= 4) {
dfu_break <- cpt.meanvar(x, penalty = "None", method = "AMOC", Q = 1)
bp <- cpts(dfu_break)
x_after <- subset(x, start = bp + 1)
dfu_break_var <- cpt.var(x, penalty = "None", method = "AMOC", Q = 1)
bp_var <- cpts(dfu_break_var)
x_after_var <- subset(x, start = bp_var + 1)
if (length(x_after) > 24) {
min_mean <- min(mean(x[1:bp]), mean(x[bp:length(x)]))
max_mean <- max(mean(x[1:bp]), mean(x[bp:length(x)]))
threshold <- p_2 * min_mean^p_1
if (max_mean / min_mean >= threshold) {
x <- x_after
} else {
if (length(x_after_var) > 24) {
min_iqr <- min(IQR(x[1:bp_var]), IQR(x[bp_var:length(x)])) + 0.0001
max_iqr <- max(IQR(x[1:bp_var]), IQR(x[bp_var:length(x)]))
if (max_iqr / min_iqr > 2) {
x <- x_after_var
} else {
x <- x
}
} else {
x <- x
}
}
if (x[1] == 0) {
x <- x_no_leading_zeros
}
return(x)
} else {
if (length(x_after_var) > 24) {
min_iqr <- min(IQR(x[1:bp_var]), IQR(x[bp_var:length(x)])) + 0.0001
max_iqr <- max(IQR(x[1:bp_var]), IQR(x[bp_var:length(x)]))
if (max_iqr / min_iqr > 2) {
x <- x_after_var
} else {
x <- x
}
} else {
x <- x
}
if (x[1] == 0) {
x <- x_no_leading_zeros
}
return(x)
}
} else {
x <- x
return(x)
}
}
}
tscut(AirPassengers)
tscut(c(1000, AirPassengers))
AirPassengers[1]
x
x <- ts(c(0,0,0, x), frequency = 12)
x
x[4] <- 1000
x
tscut(x)
min(tscut(x))
index(x)
index(x) %>% as.Date()
index(AirPassengers) %>% as.Date()
AirPassengers
index(AirPassengers)
which.min(AirPassengers)
AirPassengers
AirPassengers %>% min()
floor(x)
floor_date(x)
lubridate::floor_date(AirPassengers)
x
tscut(x)
tscut(x) %>% index()
x <- ts(c(0,0,0, x), frequency = 12, start = c(2000, 1))
x
tscut(x)
tscut(x) %>% index()
index(min(x))
index(min(tscut(x)))
tscut(x)
tscut(x)[1]
index(tscut(x)[2])
index(tscut(x)[1])
index(tscut(x))
index(tscut(x))[1]
index(tscut(x))[1] %>% as.Date()
index(tscut(x))[1] %>% as.Date(origin="1970-01-91")
index(tscut(x))[1] %>% as.Date(origin="1970-01-01")
index(tscut(x))[1] %>% as.Date(origin="1900-01-01")
index(tscut(x))[1] %>% as.Date(origin=as.Date("1900-01-01"))
time(x)
zoo::yearmon(time(x))
zoo::yearmon(time(x)[1])
as.Date(time(x)[1])
as.yearmon(time(x)[1])
as.yearmon(time(x)[1]) %>% as.Date()
tscut(x)
time(tscut(x))[1]
yearmon(time(tscut(x))[1])
zoo::as.Date(time(tscut(x))[1])
zoo::as.yearmon.default(time(tscut(x))[1])
zoo::as.yearmon(time(tscut(x))[1])
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date()
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% strptime(format = "%y")
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% strptime(format = "%m-%d-%y")
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% strptime(format = "%m-%d-%Y")
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% strptime(format = "%Y")
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% format(X$newdate, "%Y-%m-%d")
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% format("%Y-%m-%d")
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% format("%yy-%m-%d")
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% format("%y-%m-%d")
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% format("%m-%d-%y")
zoo::as.yearmon(time(tscut(x))[1]) %>% as.Date() %>% format("%m-%d-%y")
check
check()
require(devtools)
document()
check()
check()
build()
require(devtools)
check()
build()
require(devtools)
load_gbu <- function(gbu_path){
if(missing(gbu_path)){
gbu_path <- "//sinsdfs01/regional$/APJ-SC-HUB/SC.DATA/DATA/Active/Specific.GBU.Rdata"
}
load(gbu_path)
gbu <- GBU %>%
as_tibble() %>%
mutate(key=paste0(str_sub(Market.Code, start = 1, end = 2), ": ", GMID.Code)) %>%
dplyr::select(key, gmid=GMID.Code, gbu=GBU) %>%
unique() %>%
filter(gbu!="")
return(gbu)
}
load_gbu()
require(tidyverse)
load_gbu()
GBU
devtools::build()
devtools::build()
require(devtools)
build()
build()
lifesavers_path <- "//sinsdfs01/regional$/APJ-SC-HUB/SC.DATA/DATA/Active/Specific.LSD.Rdata"
local_env <- new.env()
load(lifesavers_path, envir = local_env)
local_env$LSD
names(local_env$LSD) <- c("loc", "gmid", "lsd")
local_env$LSD
local_env$LSD$key <- paste0(strtrim(local_env$GBU$market, 2), ": ", local_env$LSD$gmid)
local_env$LSD %>% head()
require(dplyr)
local_env$LSD %>% head()
local_env$LSD$key <- paste0(strtrim(local_env$GBU$loc, 2), ": ", local_env$LSD$gmid)
local_env$LSD %>% head()
local_env$LSD$key <- paste0(strtrim(local_env$LSD$loc, 2), ": ", local_env$LSD$gmid)
local_env$LSD %>% head()
local_env$LSD$key
local_env$LSD$key %>% table()
local_env$LSD$loc %>% table()
local_env$LSD$loc %>% table()
glimpse(local_env$LSD)
naniar::miss_var_summary(local_env$LSD)
lsd <- na.omit(local_env$LSD[c("key", "gmid", "lsd")])
lsd
devtools::build()
sftools:::load_gbu()
sftools:::load_lifesavers()
require(devtools)
check()
build()
require(tidyverse)
lifesavers_path <- "//sinsdfs01/regional$/APJ-SC-HUB/SC.DATA/DATA/Active/Specific.LSD.Rdata"
local_env <- new.env()
load(lifesavers_path, envir = local_env)
names(local_env$LSD) <- c("loc", "gmid", "lsd")
local_env$LSD$key <- paste0(strtrim(local_env$LSD$loc, 2), ": ", local_env$LSD$gmid)
lsd <- na.omit(local_env$LSD[c("key", "gmid", "lsd")])
lsd
gbu_path <- "//sinsdfs01/regional$/APJ-SC-HUB/SC.DATA/DATA/Active/Specific.GBU.Rdata"
local_env <- new.env()
load(gbu_path, envir = local_env)
names(local_env$GBU) <- c("market", "gmid", "activity", "activity_pfwd", "gbu")
local_env$GBU$key <- paste0(strtrim(local_env$GBU$market, 2), ": ", local_env$GBU$gmid)
gbu <- local_env$GBU[c("key", "gmid", "gbu")]
gbu <- as_tibble(gbu[gbu$key!="",])
gbu
local_env <- new.env()
load(gbu_path, envir = local_env)
names(local_env$GBU) <- c("market", "gmid", "activity", "activity_pfwd", "gbu")
local_env$GBU$key <- paste0(strtrim(local_env$GBU$market, 2), ": ", local_env$GBU$gmid)
gbu <- local_env$GBU[c("key", "gmid", "gbu")]
gbu
as_tibble(gbu[gbu$key!="|:",])
grep(x=gbu$key, pattern = ": ")
grep(x=gbu$key, pattern = "")
grepl(x=gbu$key, pattern = "")
gbu
length(gbu$key)
nchar(gbu$key)
nchar(gbu$key)<5
nchar(gbu$key)>5
as_tibble(gbu[nchar(gbu$key)>5,])
require(devtools)
check()
build()
requi
require(devtools)
build()
if (missing(gbu_path)) {
gbu_path <- "//E21flsbcnschub/BCN_SC_HUB/SC.DATA/DATA/Active/Specific.GBU.Rdata"
}
gbu_path <- "//E21flsbcnschub/BCN_SC_HUB/SC.DATA/DATA/Active/Specific.GBU.Rdata"
local_env <- new.env()
load(gbu_path, envir = local_env)
names(local_env$GBU) <- c("market", "gmid", "activity", "activity_pfwd", "gbu")
local_env$GBU$key <- paste0(strtrim(local_env$GBU$market, 2), ": ", local_env$GBU$gmid)
gbu <- local_env$GBU[c("key", "gmid", "gbu")]
gbu <- as_tibble(gbu[nchar(gbu$key)>5,])
require(dplyr)
gbu <- as_tibble(gbu[nchar(gbu$key)>5,])
gbu
lifesavers_path <- "//E21flsbcnschub/BCN_SC_HUB/SC.DATA/DATA/Active/Specific.LSD.Rdata"
local_env <- new.env()
load(lifesavers_path, envir = local_env)
names(local_env$LSD) <- c("loc", "gmid", "lsd")
local_env$LSD$key <- paste0(strtrim(local_env$LSD$loc, 2), ": ", local_env$LSD$gmid)
lsd <- as_tibble(na.omit(local_env$LSD[c("key", "gmid", "lsd")]))
lsd
build()
install.packages(c("anytime", "bayestestR", "broom", "callr", "checkmate", "customLayout", "datapasta", "dendextend", "DescTools", "digest", "dplyr", "drake", "DT", "dtplyr", "effectsize", "emmeans", "english", "fable", "fabletools", "FactoMineR", "farver", "feasts", "flextable", "foreach", "forecast", "foreign", "fracdiff", "future", "gganimate", "ggeffects", "ggpubr", "gh", "glmmTMB", "h2o", "hexbin", "Hmisc", "insight", "janitor", "jsonlite", "knitr", "labelled", "leaps", "lpSolve", "mime", "mnormt", "nlme", "parameters", "performance", "PerformanceAnalytics", "pkgcache", "plotly", "prettyunits", "processx", "ps", "raster", "rayrender", "rayshader", "RcppArmadillo", "RCurl", "remotes", "repr", "rgl", "RgoogleMaps", "rlang", "rmarkdown", "rrcov", "rstan", "rstanarm", "rstudioapi", "rvg", "sf", "shinycssloaders", "sjlabelled", "sjPlot", "sjstats", "skimr", "SparkR", "StanHeaders", "styler", "survey", "threejs", "tidyr", "tidyselect", "timeSeries", "tsDyn", "tsibble", "V8", "xaringan", "xlsx", "xts"))
library(tidyverse)
acov <- possibly(function(series, adjusted_cov=T){
series <- series[!cumsum(series)==0]
class <- class(series)
length <- length(series)
if(class=="numeric"){
series <- ts(series, start = c(1,1), frequency = 12)
}
if(length(series)>24 & adjusted_cov==T){
resi <- stl(series, s.window="periodic", robust=T)$time.series[,3]
(sd(resi[(length-11):length], na.rm = T)*sqrt((12-1)/12))/(mean(series[(length-11):length], na.rm = T))
} if(length(series)>24 & adjusted_cov!=T){
resi <- stl(series, s.window="periodic", robust=T)$time.series[,3]
(sd(resi[(length-11):length], na.rm = T)*sqrt((12-1)/12))
} if(length(series)>24 & adjusted_cov==T){
sd(series[(length-11):length], na.rm = T)/mean(series[(length-11):length], na.rm = T)
} else {
sd(series[(length-11):length], na.rm = T)
}
}, otherwise = NA)
if(class=="numeric"){
series <- ts(series, start = c(1,1), frequency = 12)
}
series<- AirPassengers
adjusted_cov==T
adjusted_cov=T
series <- series[!cumsum(series)==0]
class <- class(series)
length <- length(series)
if(class=="numeric"){
series <- ts(series, start = c(1,1), frequency = 12)
}
if(length(series)>24 & adjusted_cov==T){
resi <- stl(series, s.window="periodic", robust=T)$time.series[,3]
(sd(resi[(length-11):length], na.rm = T)*sqrt((12-1)/12))/(mean(series[(length-11):length], na.rm = T))
if(class=="numeric"){
series <- ts(series, start = c(1,1), frequency = 12)
}
if(length(series)>24 & adjusted_cov==T){
resi <- stl(series, s.window="periodic", robust=T)$time.series[,3]
(sd(resi[(length-11):length], na.rm = T)*sqrt((12-1)/12))/(mean(series[(length-11):length], na.rm = T))
} else if(length(series)>24 & adjusted_cov!=T){
resi <- stl(series, s.window="periodic", robust=T)$time.series[,3]
(sd(resi[(length-11):length], na.rm = T)*sqrt((12-1)/12))
} else if(length(series)>24 & adjusted_cov==T){
sd(series[(length-11):length], na.rm = T)/mean(series[(length-11):length], na.rm = T)
} else {
sd(series[(length-11):length], na.rm = T)
}
require(devtools)
check()
replace
?movavg
?pmax()
?stlplus
?stlplus()
install.packages("DescTools")
install.packages("DescTools")
?stlplus()
require(DescTools)
stlplus::stlplus()
?Winsorize()
require(devtools)
check()
?mad
?IQR
check()
if (missing(gbu_path)) {
if(gb=="GBU"){
gbu_path <- "//E21flsbcnschub/BCN_SC_HUB/SC.DATA/DATA/Active/Specific.GBU.Rdata"
} else {
lifesavers_path <- "//E21flsbcnschub/BCN_SC_HUB/SC.DATA/DATA/Active/Specific.LSD.Rdata"
}
}
check()
document()
?acov
check()
check()
check()
check()
check()
?na.omit()
check()
build()
require(devtools)
check()
check()
check()
#' @param ts_data tibble, dataframe or matrix. It is assumed that it is ordered by date.
#' @param cv_size numeric. Cross validation size.
#' @param lag numeric. How many periods ahead to forecast.
#'
#' @return
#' @importFrom purrr map_df
#' @importFrom dplyr tibble
#' @export
#'
#' @examples
cvts <- function(ts_data, cv_size, lag){
# define starting and ending train size
start_train <- (nrow(ts_data)-nrow(test)-lag)
stop_train <- start_train+cv_size-1
# iterate over to create tupples of train and test
map_df(start_train:stop_train
, .f = function(i){
tibble(cv = i
, train = list(ts_data[1:i,])
, test = list(ts_data[i+lag,])
)}
)
}
cvts(ts_data = dat, cv_size = 4, lag = 1)
AirPassengers
build()
build()
